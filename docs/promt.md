## **FastAPI AI Voice Agent: Architecture & Ringover Integration Guide**

**Project Vision:** To develop a robust backend system for 5 AI-powered voice agents, capable of handling a high volume of simultaneous calls (target: 20 per agent, 100 total). The system will integrate with Ringover for telephony, FastAPI as the web framework, and various LLMs (OpenAI, Gemini, Anthropic, etc., potentially via services like ElevenLabs for TTS) for intelligent responses. The FastAPI server will be responsible for initiating outbound calls (either automatically or via a future dashboard interface) and handling inbound calls. This guide outlines the technical architecture and file structure to facilitate development.

Phased Approach:  
The initial deployment will be a test phase:

* Each of the 5 AI Agents will handle 3 simultaneous calls.  
* This requires 5 Ringover Business plans and a total of 15 channels (3 channels per agent/number).  
* Upon successful testing, the system will be scaled to the full 100 simultaneous call capacity by adding more channels and potentially more numbers. This addresses the concern about committing to a one-year Ringover contract by validating the system with a smaller, less expensive setup first.

### **1\. Ringover Integration Strategy**

Ringover's developer platform (developer.ringover.com) is central to this project. The integration will primarily focus on:

* **Call Event Webhooks:** Subscribing to Ringover webhooks to receive notifications for various call events (e.g., call answered, call ended, ringing). These events are crucial for managing the state of both inbound and outbound calls within our FastAPI application.  
* **Real-time Audio Streaming via WebSockets:** Ringover should provide a mechanism to stream call audio in real-time to a WebSocket endpoint on our FastAPI server. This audio stream will be fed to the chosen LLM for processing. Conversely, audio generated by the LLM (e.g., voice responses) will be streamed back to Ringover via the WebSocket connection to be played to the callee/caller. This is vital for both inbound and server-initiated outbound calls.  
  * **Authentication:** Securely authenticate WebSocket connections.  
  * **Audio Format:** Determine the audio format (e.g., PCM, Opus) and parameters (sample rate, channels) used by Ringover and ensure compatibility with LLM services.  
* **Call Control APIs:** Using Ringover's REST APIs for actions such as:  
  * **Initiating outbound calls:** This is a primary function. The FastAPI server will use Ringover APIs to place calls to target numbers.  
  * Hanging up calls.  
  * Transferring calls (if needed).  
    The primary interaction for real-time conversation for all calls will be via WebSockets once the call is established.

**Data Flow Scenarios:**

**A. Outbound Call Flow (Server-Initiated):**

1. **Trigger:** An automated process within the FastAPI application or an action from a (future) dashboard interface triggers an outbound call.  
2. **FastAPI Initiates Call:** The FastAPI application (services/call/initiation/outbound.py) makes an API request to Ringover to initiate an outbound call to a target phone number, specifying the Ringover number to be used as the caller ID.  
3. **Ringover Places Call & Establishes WebSocket:** Ringover attempts to connect the call. Upon the callee answering, Ringover signals the call status (e.g., via webhook like call\_answered) and facilitates the setup of a WebSocket connection for audio streaming between Ringover's media server and the FastAPI server's designated endpoint.  
4. **Initial AI Interaction & Audio Streaming (System to Callee):** The AI agent might play a greeting or an initial message. TTS audio generated by the FastAPI server is streamed to Ringover via the WebSocket to be played to the callee.  
5. **Audio Streaming (Callee to System):** The callee's spoken audio is streamed from Ringover to the FastAPI server's WebSocket endpoint.  
6. **Audio Processing & LLM:** The FastAPI server receives the audio, potentially performs VAD (Voice Activity Detection) and ASR (Automatic Speech Recognition), and sends the transcribed text to the designated LLM.  
7. **LLM Response:** The LLM processes the text and returns a text response.  
8. **TTS & Audio Streaming (System to Callee):** The FastAPI server converts the LLM's text response to audio (e.g., using ElevenLabs) and streams this audio back to Ringover over the WebSocket to be played to the callee.  
9. **Call Termination:** The call can be terminated by the callee, by the FastAPI application (via Ringover API), or due to other reasons (e.g., no answer, network issues). Ringover sends webhooks (e.g., call\_hangup) to notify the FastAPI server.

**B. Inbound Call Flow:**

1. **Incoming Call:** Ringover notifies FastAPI (via webhook, e.g., incoming\_call) of an incoming call to a monitored Ringover number.  
2. **Call Accepted & WebSocket Established:** FastAPI instructs Ringover (via API, or this might be handled by Ringover routing logic based on webhook response) to accept the call. A WebSocket connection for audio is established between Ringover and the FastAPI server.  
3. **Audio Streaming (Caller to System):** Ringover streams the caller's audio to the FastAPI server's WebSocket endpoint.  
4. **Audio Processing & LLM:** (Same as step 6 in Outbound Flow)  
5. **LLM Response:** (Same as step 7 in Outbound Flow)  
6. **TTS & Audio Streaming (System to Caller):** (Same as step 8 in Outbound Flow, directed to the caller)  
7. **Call Termination:** (Same as step 9 in Outbound Flow)

### **2\. Core Technologies**

* **Web Framework:** FastAPI (for its speed, async capabilities, and ease of use).  
* **WebSocket Server:**  
  * **socketify.py:** As per your interest, this leverages uWebSockets and is known for high performance, especially with PyPy. This is a strong candidate.  
  * **Alternatives:** Standard websockets library for Python, or aiohttp.web WebSockets if socketify.py presents integration challenges. The key is robust asynchronous WebSocket handling.  
* **LLM Services:**  
  * OpenAI API  
  * Google Gemini API  
  * Anthropic Claude API  
  * Integration with services like ElevenLabs for high-quality Text-to-Speech (TTS).  
* **Databases:**  
  * **PostgreSQL:** For persistent storage of call logs, agent configurations, user data, CRM data.  
  * **Redis:** For caching, session management (e.g., ongoing call states), and potentially as a message broker for distributing tasks.  
* **CRM Integration:** Direct API calls or database integrations with your CRM.  
* **Deployment:** VPS XL plan (or similar, capable of handling the processing and network load).

### **3\. Project Structure and File Guidelines**

Guiding Principles for File Structure (For the AI Developer):  
The following structure is designed with extreme granularity in mind. Your primary goal is to keep individual Python files as short as possible, ideally focusing on a single class or a small set of related functions. Achieve this by:

1. **Maximizing Folder Depth:** Create subfolders extensively to categorize even small pieces of functionality. If a concept can be broken down, it should be placed in its own subfolder or file.  
2. **Strict Adherence to Naming Conventions:** All folder and file names **must** be lowercase. No hyphens (-), underscores (\_), camelCase, or dots (.) are allowed in folder or file names (except for \_\_init\_\_.py and file extensions like .py). Use short, descriptive names. For example, instead of call\_management\_service.py, prefer projectroot/services/call/management/logic.py or similar.  
3. **One Feature, One Place (Ideally One File):** If a file starts to exceed a few hundred lines or handles too many distinct responsibilities, consider breaking it down further into more files within more specific subdirectories.  
4. **Comprehensive Coverage:** This structure attempts to anticipate all features. If you identify a new, distinct piece of functionality during development, create new files and subfolders for it following these principles.  
5. **\_\_init\_\_.py Files:** Add \_\_init\_\_.py files to all directories and subdirectories to ensure they are treated as Python packages, allowing for imports across the structure.

projectroot/  
├── api/                       \# FastAPI REST API endpoints layer  
│   ├── v1/                    \# API version 1  
│   │   ├── calls/             \# Call related REST endpoints  
│   │   │   ├── actions/       \# Specific actions on calls  
│   │   │   │   ├── initiate.py  \# Endpoint for initiating outbound calls  
│   │   │   │   ├── terminate.py \# Endpoint for terminating calls  
│   │   │   │   ├── transfer.py  \# Endpoint for transferring calls  
│   │   │   │   ├── mute.py      \# Endpoint for muting a call  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   ├── status.py      \# Endpoint for getting call status  
│   │   │   ├── route.py       \# Main router for /calls  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── agents/            \# Agent management REST endpoints  
│   │   │   ├── config/        \# Agent configuration endpoints  
│   │   │   │   ├── route.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   ├── status.py      \# Agent status endpoint  
│   │   │   ├── route.py       \# Main router for /agents  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── webhooks/          \# Endpoints for Ringover webhooks  
│   │   │   ├── ringover/      \# Ringover specific webhook handlers  
│   │   │   │   ├── event.py   \# Handles incoming call events  
│   │   │   │   ├── route.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── schemas/           \# Pydantic schemas for API validation  
│   │   │   ├── request/       \# Request schemas  
│   │   │   │   ├── call.py  
│   │   │   │   ├── agent.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   ├── response/      \# Response schemas  
│   │   │   │   ├── call.py  
│   │   │   │   ├── agent.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   └── \_\_init\_\_.py  
├── core/                      \# Core application settings, utilities, and configurations  
│   ├── config/                \# Application configuration files  
│   │   ├── app/               \# General application settings  
│   │   │   ├── main.py        \# e.g., app name, version, debug mode  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── providers/         \# External provider API keys and settings  
│   │   │   ├── ringover.py  
│   │   │   ├── database.py  
│   │   │   ├── redis.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── services/          \# Configurations for specific integrated services  
│   │   │   ├── llm/           \# LLM related configurations  
│   │   │   │   ├── openai.py  
│   │   │   │   ├── gemini.py  
│   │   │   │   ├── anthropic.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   ├── tts/  
│   │   │   │   ├── elevenlabs.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   ├── stt/  
│   │   │   │   ├── whisper.py \# Example STT provider  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   ├── security/              \# Security related utilities  
│   │   ├── auth/              \# Authentication mechanisms  
│   │   │   ├── token.py       \# JWT token logic, API key validation  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── crypto/            \# Cryptographic helpers  
│   │   │   ├── hash.py        \# Hashing utilities (e.g., for HMAC)  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   ├── logging/               \# Logging configuration and setup  
│   │   ├── setup.py         \# Initializes loggers, formatters, handlers  
│   │   ├── format.py        \# Custom log formats  
│   │   ├── handler.py       \# Custom log handlers (if any)  
│   │   └── \_\_init\_\_.py  
│   ├── utils/                 \# Common, small utility functions  
│   │   ├── timeutil.py      \# Time and date utilities  
│   │   ├── stringutil.py    \# String manipulation utilities  
│   │   ├── networkutil.py   \# Network related utilities  
│   │   └── \_\_init\_\_.py  
│   └── \_\_init\_\_.py  
├── data/                      \# Data access layer (databases, CRM, etc.)  
│   ├── db/                    \# PostgreSQL interaction  
│   │   ├── connection.py      \# Database connection setup (engine, session)  
│   │   ├── base.py            \# Base for SQLAlchemy models  
│   │   ├── models/            \# SQLAlchemy ORM models  
│   │   │   ├── calllog.py     \# Call log data model  
│   │   │   ├── agentconfig.py \# Agent configuration model  
│   │   │   ├── transcript.py  \# Call transcript model  
│   │   │   ├── userprofile.py \# User/Contact profile from CRM/DB  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── ops/               \# Database operations (CRUD)  
│   │   │   ├── call/          \# Operations for call related data  
│   │   │   │   ├── create.py  
│   │   │   │   ├── read.py  
│   │   │   │   ├── update.py  
│   │   │   │   ├── delete.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   ├── agent/         \# Operations for agent data  
│   │   │   │   ├── create.py  
│   │   │   │   ├── read.py  
│   │   │   │   ├── update.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   ├── transcript/  
│   │   │   │   ├── save.py  
│   │   │   │   ├── retrieve.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   ├── redis/                 \# Redis interaction  
│   │   ├── connection.py      \# Redis client setup  
│   │   ├── ops/               \# Redis operations  
│   │   │   ├── session/       \# Call session state management  
│   │   │   │   ├── store.py  
│   │   │   │   ├── retrieve.py  
│   │   │   │   ├── delete.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   ├── cache/         \# General purpose caching  
│   │   │   │   ├── get.py  
│   │   │   │   ├── set.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   ├── ratelimit/     \# Rate limiting logic using Redis  
│   │   │   │   ├── check.py  
│   │   │   │   └── \_\_init\_\_.py  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   ├── crm/                   \# CRM integration methods  
│   │   ├── client.py          \# Base CRM API client  
│   │   ├── contact/           \# Contact related CRM operations  
│   │   │   ├── get.py  
│   │   │   ├── create.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── activity/          \# Logging call activity to CRM  
│   │   │   ├── log.py  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   └── \_\_init\_\_.py  
├── models/                    \# Pydantic models for data structures (DTOs, distinct from DB models)  
│   ├── internal/              \# Internal data structures used between services  
│   │   ├── callcontext.py     \# Model for ongoing call context  
│   │   ├── agentstate.py      \# Model for AI agent state  
│   │   └── \_\_init\_\_.py  
│   ├── external/              \# Models for data from/to external systems  
│   │   ├── ringover/          \# Ringover specific payloads  
│   │   │   ├── webhook.py     \# Pydantic models for Ringover webhook payloads  
│   │   │   ├── apirequest.py  \# Models for requests to Ringover API  
│   │   │   ├── apiresponse.py \# Models for responses from Ringover API  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── llm/  
│   │   │   ├── request.py  
│   │   │   ├── response.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── tts/  
│   │   │   ├── request.py  
│   │   │   ├── response.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── stt/  
│   │   │   ├── request.py  
│   │   │   ├── response.py  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   └── \_\_init\_\_.py  
├── services/                  \# Business logic and external service integrations  
│   ├── call/                  \# Call management service  
│   │   ├── initiation/        \# Logic for starting calls  
│   │   │   ├── outbound.py    \# Handles outbound call initiation sequence  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── management/        \# Core call lifecycle management  
│   │   │   ├── inbound.py     \# Handles inbound call sequence  
│   │   │   ├── supervisor.py  \# Oversees active calls, state transitions  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── state/             \# Call state tracking and updates  
│   │   │   ├── tracker.py     \# Tracks current state of each call  
│   │   │   ├── updater.py     \# Updates call state in Redis/DB  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── transcription/     \# Manages call transcription  
│   │   │   ├── live.py        \# Real-time transcription processing  
│   │   │   ├── storage.py     \# Storing final transcripts  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── audioprocessing/   \# Specific audio manipulations for calls  
│   │   │   ├── vad.py         \# Voice Activity Detection logic  
│   │   │   ├── formatting.py  \# Audio format conversions for calls  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   ├── agent/                 \# Agent logic and persona management  
│   │   ├── assignment/        \# Assigning calls to agent logic/persona  
│   │   │   ├── router.py      \# Routes call to appropriate agent logic  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── profile/           \# Managing agent profiles/configurations  
│   │   │   ├── loader.py      \# Loads agent profiles from DB  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── persona/           \# Applying agent persona to interactions  
│   │   │   ├── prompt.py      \# Generates persona-specific system prompts  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   ├── llm/                   \# LLM interaction service  
│   │   ├── providers/         \# Clients for specific LLM providers  
│   │   │   ├── base.py        \# Base class for LLM provider clients  
│   │   │   ├── openai.py  
│   │   │   ├── gemini.py  
│   │   │   ├── anthropic.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── prompting/         \# Logic for constructing LLM prompts  
│   │   │   ├── builder.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── contextualization/ \# Managing conversation history/context  
│   │   │   ├── history.py     \# Manages conversation history  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── streaming/         \# Handling LLM stream responses  
│   │   │   ├── processor.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── orchestrator.py    \# Main logic to get LLM response  
│   │   └── \_\_init\_\_.py  
│   ├── tts/                   \# Text-to-Speech service integration  
│   │   ├── providers/  
│   │   │   ├── base.py  
│   │   │   ├── elevenlabs.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── streaming/  
│   │   │   ├── processor.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── orchestrator.py  
│   │   └── \_\_init\_\_.py  
│   ├── stt/                   \# Speech-to-Text service integration  
│   │   ├── providers/  
│   │   │   ├── base.py  
│   │   │   ├── whisperclient.py \# Example  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── streaming/  
│   │   │   ├── processor.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── orchestrator.py  
│   │   └── \_\_init\_\_.py  
│   ├── notification/          \# Service for sending notifications (e.g., alerts)  
│   │   ├── email/  
│   │   │   ├── send.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── sms/  
│   │   │   ├── send.py  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   ├── taskqueue/             \# Integration with background task queues (Celery, ARQ)  
│   │   ├── tasks/             \# Define background tasks here  
│   │   │   ├── report.py      \# Example: generating a post-call report  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── worker.py          \# Worker setup (if managed within this app)  
│   │   └── \_\_init\_\_.py  
│   └── \_\_init\_\_.py  
├── wss/                       \# WebSocket server logic (for audio streaming)  
│   ├── connection/            \# WebSocket connection management  
│   │   ├── manager.py         \# Handles overall WebSocket connections, registry  
│   │   ├── auth.py            \# Authentication for WebSocket connections  
│   │   └── \_\_init\_\_.py  
│   ├── handlers/              \# WebSocket message handlers for different types  
│   │   ├── audio/             \# Handles audio data packets  
│   │   │   ├── receive.py  
│   │   │   ├── send.py  
│   │   │   └── \_\_init\_\_.py  
│   │   ├── control/           \# Handles control messages over WebSocket (if any)  
│   │   │   ├── event.py  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   ├── protocol/              \# Defines WebSocket message structures if complex  
│   │   ├── format.py          \# Defines format of messages (e.g. JSON with specific fields)  
│   │   ├── parser.py          \# Parses incoming messages  
│   │   └── \_\_init\_\_.py  
│   ├── endpoint.py            \# Main WebSocket endpoint definition for FastAPI  
│   └── \_\_init\_\_.py  
├── tests/                     \# Unit and integration tests  
│   ├── unit/                  \# Unit tests, mirroring project structure  
│   │   ├── api/  
│   │   ├── core/  
│   │   ├── data/  
│   │   ├── services/  
│   │   ├── wss/  
│   │   └── \_\_init\_\_.py  
│   ├── integration/           \# Integration tests  
│   │   ├── api/  
│   │   ├── services/  
│   │   ├── fullflow/          \# End-to-end flow tests  
│   │   │   └── \_\_init\_\_.py  
│   │   └── \_\_init\_\_.py  
│   ├── fixtures/              \# Test fixtures and mock data  
│   │   ├── data.py  
│   │   └── \_\_init\_\_.py  
│   └── \_\_init\_\_.py  
├── tools/                     \# Utility scripts for development, deployment, ops  
│   ├── deploy/  
│   │   ├── script.py  
│   │   └── \_\_init\_\_.py  
│   ├── datamigration/  
│   │   ├── migrate.py  
│   │   └── \_\_init\_\_.py  
│   └── \_\_init\_\_.py  
├── main.py                    \# Main application entry point (initializes FastAPI app)  
├── requirements.txt           \# Python dependencies (consider requirements-dev.txt too)  
└── README.md                  \# Project documentation

**Explanation of Key Folders and Files (Revised for Granularity):**

* **api/**: All HTTP interface logic. Endpoints are extremely focused.  
  * actions/: Individual files for each callable action on a resource (e.g., api/v1/calls/actions/initiate.py).  
  * schemas/: Pydantic models are separated by request/ and response/ and then by resource.  
* **core/**: Essential application-wide components.  
  * config/: Configuration is broken down by app/, providers/ (for external API keys like Ringover, DB), and services/ (for specific behaviors of LLM, TTS, STT integrations).  
  * security/: Specific files for auth/token.py and crypto/hash.py.  
  * utils/: Houses tiny, reusable helper functions (e.g., timeutil.py).  
* **data/**: Interaction with all persistent and semi-persistent data stores.  
  * db/ops/: CRUD operations are broken down per resource and then per operation type (e.g., data/db/ops/call/create.py).  
  * redis/ops/: Specific operations for session/ management, cache/, and ratelimit/.  
  * crm/: Broken into contact/ and activity/ logging.  
* **models/ (Pydantic DTOs)**: Data Transfer Objects are now categorized into internal/ (for service-to-service data flow) and external/ (for mapping to third-party systems like Ringover, LLMs).  
  * external/ringover/: Has distinct files for webhook.py payloads, apirequest.py, and apiresponse.py.  
* **services/**: This layer sees the most significant expansion to ensure business logic files are minimal.  
  * Each primary service (call, agent, llm, tts, stt) is heavily sub-moduled.  
  * services/call/: Has distinct subdirectories for initiation/, management/, state/, transcription/, and audioprocessing/. Each of these then contains specific logic files.  
  * services/llm/: Includes providers/ (as before), but adds prompting/, contextualization/, and streaming/ to separate these concerns.  
  * services/tts/ and services/stt/: Mirror the llm structure with providers/ and streaming/.  
  * services/notification/: A new service for any alerting needs.  
  * services/taskqueue/: For defining and managing background tasks if using Celery/ARQ.  
* **wss/**: WebSocket-specific logic.  
  * connection/: Includes manager.py for the overall registry and auth.py for WS connection security.  
  * handlers/: Separates audio/receive.py and audio/send.py, and allows for control/event.py if other WS message types are needed.  
  * protocol/: If the WebSocket communication involves a custom complex protocol beyond simple audio/JSON, its definition and parsing logic go here.  
  * endpoint.py: Contains the main FastAPI WebSocket route handler(s).  
* **tests/**: Testing structure mirrors the main application's granularity, with unit/ and integration/ subdirectories throughout.  
* **tools/**: For helper scripts not part of the main application runtime (e.g., deployment scripts, data migration utilities).  
* **main.py**: Remains the entry point, assembling the FastAPI app, mounting routers, etc.

This highly granular structure, while verbose in definition, is intended to force the creation of many small, focused files, aligning with the user's explicit preference.

### **4\. Key Technical Guidelines for AI Agent (Developer)**

This section is written as if instructing an AI or a developer on building the system.

**You are tasked with building a FastAPI backend for AI Voice Agents, following the detailed file structure provided in Section 3\.**

**Key Instructions:**

1. **Strictly Adhere to File Structure and Naming:** Implement all code within the exact folder and file paths specified. Create new files and subfolders if a piece of logic doesn't fit neatly or makes an existing file too long, always following the "short files, deep nesting, lowercase names" principle.  
2. **Configuration Management (core/config/):**  
   * Implement all configurations (API keys, database URLs, model names, Ringover settings) using environment variables, loaded via Pydantic BaseSettings in the specific files within core/config/providers/ and core/config/services/.  
   * Ensure sensitive keys (Ringover, LLMs) are never hardcoded.  
   * Provide clear instructions on which environment variables need to be set for each configuration file.  
3. **Outbound Call Initiation (api/v1/calls/actions/initiate.py, services/call/initiation/outbound.py):**  
   * **API Endpoint:** The FastAPI endpoint logic in api/v1/calls/actions/initiate.py should handle request validation (using schemas from api/v1/schemas/request/call.py) and then call the service layer.  
   * **Service Logic:** Implement the core outbound call placement logic in services/call/initiation/outbound.py. This includes:  
     * Interfacing with the Ringover API (via a client possibly defined in services/ringoverclient.py or similar, using configs from core/config/providers/ringover.py).  
     * Handling Ringover's response, obtaining a call\_id.  
     * Managing the initial state of the outbound call (e.g., dialing, ringing) using services/call/state/updater.py.  
     * Coordinating WebSocket audio stream setup upon call\_answered (event handled by webhook, then triggering logic in services/call/management/supervisor.py or wss/connection/manager.py).  
   * **Error Handling:** Robustly handle errors during call initiation.  
4. **Ringover Webhook Handling (api/v1/webhooks/ringover/event.py):**  
   * Implement endpoint logic here. Secure with HMAC verification (using core/security/crypto/hash.py).  
   * Parse webhook payloads using Pydantic models from models/external/ringover/webhook.py.  
   * Delegate processing to relevant service modules, e.g., services/call/management/supervisor.py or services/call/state/updater.py based on event type (incoming\_call, call\_answered, call\_hangup).  
5. **WebSocket Connection Management (wss/endpoint.py, wss/connection/manager.py, wss/connection/auth.py):**  
   * Define the main WebSocket endpoint in wss/endpoint.py.  
   * wss/connection/manager.py will register/unregister connections, mapping call\_id to WebSocket objects.  
   * wss/connection/auth.py will handle authentication for incoming WebSocket connection requests from Ringover's media servers.  
   * Implement robust error handling for WebSocket lifecycles.  
6. **Real-time Audio Handling (wss/handlers/audio/receive.py, wss/handlers/audio/send.py, services/stt/, services/tts/):**  
   * **Receiving Audio (wss/handlers/audio/receive.py):**  
     * Continuously receive binary audio chunks from the WebSocket.  
     * Forward these chunks to services/stt/streaming/processor.py, which in turn uses an STT provider client from services/stt/providers/.  
   * **VAD (services/call/audioprocessing/vad.py):** Integrate VAD logic here if needed, to be called by the STT streaming processor or call management logic.  
   * **ASR (services/stt/orchestrator.py):** This coordinates the STT process.  
   * **Sending Audio (wss/handlers/audio/send.py):**  
     * Receives synthesized audio chunks (likely from services/tts/streaming/processor.py).  
     * Streams these chunks back to Ringover via the WebSocket.  
7. **LLM Interaction (services/llm/):**  
   * **Provider Abstraction:** Use services/llm/providers/base.py and specific provider files.  
   * **Prompting (services/llm/prompting/builder.py):** Construct LLM prompts.  
   * **Context (services/llm/contextualization/history.py):** Manage conversation history.  
   * **Streaming (services/llm/streaming/processor.py):** Handle streamed LLM responses.  
   * **Orchestration (services/llm/orchestrator.py):** Central logic to get LLM responses.  
8. **Text-to-Speech (TTS) Integration (services/tts/):**  
   * Similar structure to LLM: providers/ (e.g., elevenlabs.py), streaming/processor.py, and orchestrator.py.  
   * Ensure TTS output format matches what wss/handlers/audio/send.py expects for Ringover.  
9. **State Management (services/call/state/tracker.py, services/call/state/updater.py, data/redis/ops/session/):**  
   * Track call states (defined possibly in models/internal/callcontext.py) using tracker.py.  
   * Update states via updater.py, which interfaces with data/redis/ops/session/store.py for Redis and data/db/ops/call/update.py for persistent DB updates.  
10. **Agent Logic (services/agent/):**  
    * services/agent/profile/loader.py loads configurations from data/db/ops/agent/read.py.  
    * services/agent/persona/prompt.py generates system prompts based on the loaded profile.  
    * services/agent/assignment/router.py decides which agent logic/persona to use for a call.  
11. **Database Operations (data/db/ops/):**  
    * All SQL interactions must go through files in this directory (e.g., data/db/ops/call/create.py). Services call these granular functions.  
    * Use SQLAlchemy models defined in data/db/models/. Connection setup in data/db/connection.py.  
12. **CRM Integration (data/crm/):**  
    * data/crm/client.py for base API interaction. Specific operations in contact/ and activity/.  
13. **Concurrency and Asynchronous Operations:**  
    * Ensure all I/O is async/await. FastAPI handles this well.  
    * For long-running, non-real-time tasks, consider defining them in services/taskqueue/tasks/ and invoking them.  
14. **Error Handling and Logging (core/logging/setup.py):**  
    * Use the centralized logging configured in core/logging/setup.py throughout the application.  
    * Implement specific exception handling within each service and API endpoint.  
15. **Scalability:**  
    * Design with the target load in mind. Stateless services are preferred, with state managed externally (Redis, DB).  
    * The detailed structure should help isolate performance bottlenecks.  
16. **Security (core/security/):**  
    * Apply authentication from core/security/auth/token.py to relevant API endpoints.  
    * Use HMAC logic from core/security/crypto/hash.py for webhooks.  
    * Validate all inputs using Pydantic schemas from api/v1/schemas/.  
17. **Testing (tests/):**  
    * Write unit tests in tests/unit/ mirroring the granular structure of your source code.  
    * Write integration tests in tests/integration/, especially for service interactions and API flows.  
    * Use tests/fixtures/ for reusable test data and mocks.

This highly detailed structure and set of guidelines should provide a solid foundation for building your AI Voice Agent system. The emphasis on small, focused files and clear separation of concerns will aid in maintainability and scalability. Remember to consult Ringover's specific API documentation for the exact details of their outbound call initiation, WebSocket audio streaming, and webhook event formats.
